# -*- coding: utf-8 -*-
"""AML_Fraud_Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10JsyWpPOd2O2GfXphGN_fJTUAbkk5Ck9
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from keras.models import Sequential
from keras.layers import Dense, Dropout, BatchNormalization
from keras.optimizers import Adam
from sklearn.utils import class_weight
import numpy as np


def fraud_detection(json_file_path, model_file_path):
    # Load data
    data = pd.read_json(json_file_path)

    # Adjust column names with extra spaces
    data.columns = data.columns.str.strip()

    # Convert 'CHQ.NO.' to numeric
    data['CHQ_NO'] = pd.to_numeric(data['CHQ_NO'], errors='coerce')

    # Divide selected columns by 45
    cols_to_divide = ['CHQ_NO', 'DEPOSIT_AMT', 'WITHDRAWAL_AMT']
    data[cols_to_divide] /= 45

    selected_columns = cols_to_divide
    X = data[selected_columns]
    y = data['isFraud']

    # Handle missing values
    X = X.fillna(0)

    le = LabelEncoder()
    y = le.fit_transform(y)

    # Split data
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.9, random_state=42)

    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)

    # Compute class weights to handle imbalanced classes
    class_weights = class_weight.compute_class_weight(
        'balanced', classes=np.unique(y_train), y=y_train)

    # Build a more complex model with BatchNormalization
    model = Sequential()
    model.add(Dense(256, input_dim=len(selected_columns), activation='relu'))
    model.add(BatchNormalization())
    model.add(Dropout(0.5))
    model.add(Dense(128, activation='relu'))
    model.add(BatchNormalization())
    model.add(Dropout(0.5))
    model.add(Dense(64, activation='relu'))
    model.add(BatchNormalization())
    model.add(Dropout(0.5))
    model.add(Dense(32, activation='relu'))
    model.add(Dense(1, activation='sigmoid'))

    # Compile model with adjusted learning rate and class weights
    model.compile(loss='binary_crossentropy', optimizer=Adam(
        learning_rate=0.0001), metrics=['accuracy'])

    # Train the model for more epochs with class weights
    model.fit(X_train_scaled, y_train, epochs=5, batch_size=64, validation_data=(
        X_test_scaled, y_test), class_weight=dict(enumerate(class_weights)))

    # Evaluate the updated model
    loss, accuracy = model.evaluate(X_test_scaled, y_test)
    print(f'Accuracy: {accuracy}')

    # Save the model
    model.save(model_file_path)
    from keras.models import load_model

    # Load the model
    loaded_model = load_model(model_file_path)

    # Assuming 'scaler' is the scaler used during training

    # Corrected new_data as a dictionary
    new_data = {
        "CHQ_NO": 0,
        "WITHDRAWAL_AMT": 0,
        "DEPOSIT_AMT": 28000,
    }

    last_data = data.tail(1)
    last_data = last_data[selected_columns]

    # Scale the last data using the same scaler
    last_data_scaled = scaler.transform(last_data)

    # Make predictions
    predictions = loaded_model.predict(last_data_scaled)

    # Output the result
    print("predictions[0][0]")
    print(predictions[0][0])
    if predictions[0][0] >= 0.5:
        print("Fraudulent Transaction")
        return 1
    else:
        print("NOT Fraudulent Transaction")
        return 0
